/* Copyright (c) 2015-2016 Jesse Waite */

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.Xna.Framework.Input;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework;
using System.Timers;

namespace MissileCommand.Input
{
  /// <summary>
  /// The Reticle stores the mouse state(s) and applying algorithms to this history to implement
  /// event-based click inputs. For instance, detecting when a series of inputs seems to have
  /// converged on some local region, such that we can call it a "click" and register it as such
  /// to send down into the GameFramework. This object is where different algorithms for eye-based
  /// interaction can be implemented, tuned, tinkered: filtering, interpreting, swiping, etc. Check
  /// out pipe and filter patterns, which will likely be the basis of most algorithms.
  /// 
  /// The Reticle probably seems like it belongs in the GameFramework as an IGameObject, however
  /// it is really a property of the view, since it is the point of interaction between the view
  /// and the user. The distinction is important for understanding the view/model timing diagrams.
  /// 
  /// StandardReticle state machine: the cursor continues to acquire the mousestate, signalling a click
  /// when the product of x and y stdev (over some weighted function of recent inputs) falls
  /// below an experimentally-determined threshold. The MouseClick pulse is held only until some client
  /// calls GetState(). This prevents multiple clicks for the same click event, basically a debounce.
  /// There is more detail than that, especially for debounce strategies, but that's the gist: user
  /// focuses on a point, and we signal one and only one click.
  /// </summary>
  public class Reticle : IReticle
  {
    IMouseDevice _mouse;
    SpriteLoaderFlyweight _textureLoader;
    string _resourcePath;
    int _width, _height;
    int EYE_DEVICE_HZ = 60;

    public Reticle(bool eyeMode, string resourcePath, SpriteLoaderFlyweight textureFlyweight)
    {
      if(eyeMode)
      {
        _mouse = new EyeDevice(EYE_DEVICE_HZ);
      }
      else
      {
        _mouse = new MouseDevice();
      }

      _resourcePath = resourcePath;
      _textureLoader = textureFlyweight;
      _width = 30;
      _height = 30;
    }

    /// <summary>
    /// Returns an artificial MouseState generated by our algorithms.
    /// </summary>
    /// <returns></returns>
    public MouseState GetMouseState()
    {
      return _mouse.GetMouseState();
    }

    public void Draw(SpriteBatch spriteBatch, ContentManager contentManager)
    {
      Texture2D texture = _textureLoader.LoadTexture2D(_resourcePath, contentManager, true);
      int x = _mouse.GetMouseState().X - _width / 2;
      int y = _mouse.GetMouseState().Y - _height / 2;
      spriteBatch.Draw(texture, new Rectangle(x, y, _width, _height), Color.White);
    }
  }
}
